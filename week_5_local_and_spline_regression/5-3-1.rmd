---
title: ""
output: html_notebook
---

This question uses the variables `dis` (the weighted mean of distances to five Boston employment centers) and `nox` (nitrogen oxides concentration in parts per 10 million) from the `Boston` data. We will treat `dis` as the predictor and `nox` as the response.

# Question 1
Use the poly()poly() function to fit a cubic polynomial regression to predict noxnox using disdis. Report the regression output, and plot the resulting data and polynomial fits. Note that for this question and the following, we will consider an orthogonal polynomial basis, leaving the default argument raw=FALSE.

```{r}
library(MASS)
m <- lm(nox ~ poly(dis, 3), data=Boston )
summary(m)
```




```{r}
plot( Boston$dis, Boston$nox, xlab='dis', ylab='nox', main='third degree polynomial fit' )
dis_range <- range(Boston$dis )
dis_samples <- seq(from=dis_range[1], to=dis_range[2], length.out=100 )
y_hat <- predict(m, newdata=list(dis=dis_samples ) )

lines( dis_samples, y_hat, col='red' )
```

# Question 2
Plot the polynomial fits for a range of different polynomial degrees (say, from 1 to 10), and report the associated residual sum of squares.

```{r}
library(MASS)
d_max <- 10
# The training RSS:
training_rss <- rep(NA, d_max)
for( d in 1:d_max ){
  m <- lm(nox ~ poly(dis, d), data=Boston )
  training_rss[d] <- sum(( m$residuals )^2 )
}
```

# Question 3
Perform cross-validation or another approach to select the optimal degree for the polynomial, and explain your results.

```{r}
library(MASS)
set.seed(1)
k <- 10
d_max <- 10
folds <- sample(1:k, nrow(Boston), replace=TRUE )
cv.rss.test <- matrix(NA, k, d_max )
cv.rss.train <- matrix(NA, k, d_max )

for( d in 1:d_max ){
  for( fi in 1:k ){ # for each fold
    fit <- lm(nox ~ poly(dis, d), data=Boston[folds!=fi,] )

    y_hat <- predict(fit, newdata=Boston[folds!=fi,] )
    cv.rss.train[fi,d] <- sum(( Boston[folds!=fi,]$nox - y_hat )^2 )

    y_hat <- predict(fit, newdata=Boston[folds==fi,] )
    cv.rss.test[fi,d] <- sum(( Boston[folds==fi,]$nox - y_hat )^2 )
  }
}

cv.rss.train.mean <- apply(cv.rss.train, 2, mean)
cv.rss.train.stderr <- apply(cv.rss.train, 2, sd)/sqrt(k)

cv.rss.test.mean <- apply(cv.rss.test, 2, mean)
cv.rss.test.stderr <- apply(cv.rss.test, 2, sd)/sqrt(k)

min_value <- min(c(cv.rss.test.mean, cv.rss.train.mean) )
max_value <- max(c(cv.rss.test.mean, cv.rss.train.mean) )

plot( 1:d_max, cv.rss.train.mean, xlab='polynomial degree', ylab='RSS', col='red', pch=19, type='b', ylim=c(min_value,max_value) )
lines( 1:d_max, cv.rss.test.mean, col='green', pch=19, type='b' )
legend( "topright", legend=c("train RSS","test RSS"), col=c("red","green"), lty=1, lwd=2 )
```

# Question 4
Use the `bs()` function to fit a regression spline to predict `nox` using `dis`.  How would you choose the knots? Plot the resulting fit.  Report the output for the fit using four degrees of freedom.

```{r}
library(MASS)
library(splines)
m <- lm(nox ~ bs(dis, df=4), data=Boston )
plot( Boston$dis, Boston$nox, xlab='dis', ylab='nox', main='bs with df=4 fit' )

dis_range <- range(Boston$dis )
dis_samples <- seq(from=dis_range[1], to=dis_range[2], length.out=100 )
y_hat <- predict(m, newdata=list(dis=dis_samples ) )
lines( dis_samples, y_hat, col='red' )
```

# Question 5
Now fit a regression spline for a range of degrees of freedom, and plot the resulting fits and report the resulting RSS. Describe the results obtained.

Next, perform cross-validation or another approach to select the best degrees of freedom for a regression spline on this data. Describe your results.

```{r}
library(MASS)
library(splines)
set.seed(1)
dof_choices = c(3:15)
n_dof_choices = length(dof_choices)

# The RSS estimated using cross-validation:

k = 5
folds = sample( 1:k, nrow(Boston), replace=TRUE )
cv.rss.test = matrix( NA, k, n_dof_choices )
cv.rss.train = matrix( NA, k, n_dof_choices )

for( di in 1:n_dof_choices ){
   for( fi in 1:k ){ # for each fold
      fit = lm( nox ~ bs(dis,df=dof_choices[di]), data=Boston[folds!=fi,] )

      y_hat = predict( fit, newdata=Boston[folds!=fi,] )
      cv.rss.train[fi,di] = sum( ( Boston[folds!=fi,]$nox - y_hat )^2 )

      y_hat = predict( fit, newdata=Boston[folds==fi,] )
      cv.rss.test[fi,di] = sum( ( Boston[folds==fi,]$nox - y_hat )^2 )
   }
}

cv.rss.train.mean = apply(cv.rss.train,2,mean)
cv.rss.train.stderr = apply(cv.rss.train,2,sd)/sqrt(k)

cv.rss.test.mean = apply(cv.rss.test,2,mean)
cv.rss.test.stderr = apply(cv.rss.test,2,sd)/sqrt(k)

min_value = min( c(cv.rss.test.mean,cv.rss.train.mean) )
max_value = max( c(cv.rss.test.mean,cv.rss.train.mean) )

plot( dof_choices, cv.rss.train.mean, xlab='spline d.o.f.', ylab='Train-RSS', col='red', pch=19, type='b' )

plot( dof_choices, cv.rss.test.mean, xlab='spline d.o.f.', ylab='Test-RSS', col='red', pch=19, type='b' )
```

In using the `bs()` function we choose to specify the splines degree of freedom via cross-validation. This will place the knots at the percentile points of the data with a large degrees of freedom corresponding to more knots in the domain. The test RSS seems to be minimal for the degrees of freedom equal to six.

```{r}

```
